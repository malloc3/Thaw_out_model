#Default Values.  (WARNING THIS CHANGES ALL DEFAULT VALUES IN THIS FUNCTION)
default_smelt = 0 #The value that Melt must be less than to consider for melt out
default_snot_melt = 10 #The Value that Melt must be greater than to consider not melt
default_prev_days = 2 # The number of days previous to the date that must be
# greater than Snot_Melt
default_all_or_any = "any"  #can also be set to "any"
default_area_value_method = "Sum.Melt"
# This function tests if a specific date matches the "melt_out_date" criteria
# True if Snow Melt at Date is less than Smelt_out threshold AND
#    Snow Melt of previous 50 days > Snot_melt threshold
# Else
#   False
#
#  IMPORTANT:  This function only works for SWE and SWEHybrid.  There would need
#     to be a different function if we were interested in using Melt to determin
#     melt out.  I would argue that using melt does not make sense since melt
#     is still happending nonce melt out occurs.  And that melt out is a
#     somehwat arbitrarie value associated with a pond "opening" and NOT with
#     all snow being gone.
#
#
# Input
# date = A specific Date
# site_melt_data = Df of a SINGLE site melt
#     Each of constants associated with these methods must be thought through
#       carefully to tune our melt date appropriately.
#
# (OPTIONAL)  Below
# master_df = dataframe from wich the .data pronoun can compair to recreate dataframe (see make_dataframe_from_data)
# all_or_any_previous = String either "all" or "any"   Deliniates if all dates within previous days or any dates within previous days must be greater than the Snot_melt value
# area_value_method = String (Sum.Melt, Median.Melt, Mean.Melt, Max.Melt, Min.Melt) The method with wich the areas melt value is averaged/summed etc
# Smelt_out, Snot_Melt, previous_days = Numerical  Descriptions above in default params
#
#
# Return
#   Boolean = TRUE or FALSE if the target date matches the criteria for being a "melt out date"
is_melt_date_sum = function(target_date, site_melt_data, master_df = NULL, all_or_any_string = default_all_or_any, area_value_method = default_area_value_method, Smelt_out = default_smelt, Snot_melt = default_snot_melt, previous_days = default_prev_days){
if (!is.data.frame(site_melt_data)){
if(is.list(site_melt_data)){
site_melt_data = make_dataframe_from_data(site_melt_data, master_df)
}else{
stop("site_melt_data is neither a DF nor a .data type.")
}
}
check_if_not_swe_or_sweHybrid(site_melt_data) #Checks if this is the "melt" meltType
# Gets previous dates etc
temp_previous_days_df = site_melt_data[site_melt_data$Date >= (target_date - previous_days), ]
previous_days_df = temp_previous_days_df[temp_previous_days_df$Date < target_date, ]
if (nrow(previous_days_df) < (previous_days-1)){
warning("For the date below the 'previous days' calculation resulted in fewer than the required number of days and the date was dropped.")
warning(target_date)
warning(nrow(previous_days_df))
print("CHECK THE WARNINGS")
return(FALSE)
}
melt_value = site_melt_data[[area_value_method]][site_melt_data$Date == target_date]
if (melt_value <= Smelt_out && all_or_any(previous_days_df, area_value_method, Snot_melt, all_or_any_string) && nrow(previous_days_df) > 0 ){
print("Came out True")
print(target_date)
return(TRUE)
}else{
return(FALSE)
}
}
#INTERNAL USE ONLY
# Evals the all or any condition and perform evaulation on the df
# input
#   previous_days_df = df of all previous days
#   area_valuy_method = string representing the area_value_method
#   all_or_any_string = string delineating any or all
all_or_any = function(previous_days_df, area_value_method, Snot_melt, all_or_any_string){
if (all_or_any_string == "all"){
return(all(previous_days_df[[area_value_method]] >= Snot_melt))
}else if (all_or_any_string == "any"){
return(any(previous_days_df[[area_value_method]] >= Snot_melt))
}else{
stop("any or all variable is not equalt to 'any' or 'all")
}
}
# This is for PIPE operations!   Custom function designed to work with single
# Variables must be Verctorized to work with pip operan
vectorized_is_melt_date_sum <- Vectorize(is_melt_date_sum, "target_date", "site_melt_data")
#makes a dataframe from the .data pronoun.   This is highly annoying but required
# There is some assumption that R will not jumble the lists when we pull them from
# the .data pronoun.   This assumption has not been completely confirmed and is hard to check
# This is done by creating a small dataframe from the .data function and then merging it
# with the larger dataframe and retaining only those rows that match!   It should end up
# being the same length.  If not then something has gone horribly wrong and will throw
# an error
# Input
#   the.data = Pronoun the .data pronoun.   cannot use .data directly without throwing error
#    master_df = large dataframe give that contains all of the .data
make_dataframe_from_data = function(the.data, master_df){
if (is.null(master_df)){stop("the master DF is null")}
date_list = the.data$Date
site_id_list = the.data$site_id
melt_list = the.data$melt_types
the.data_DF = data.frame(Date = date_list, site_id = site_id_list, melt_types = melt_list)
reduced_df = merge(master_df, the.data_DF, by = c("Date", "site_id", "melt_types"))
if (nrow(reduced_df) != length(date_list)){
stop("Something went wrong recreating the .data dataframe the lengths do not match")
}
return(reduced_df)
}
#  This checks if the user passed a DF that has meltType that is Melt
# Rather has a melt type that is NOT swe or sweHybrid.   These methods only work
# with SWE melt types
check_if_not_swe_or_sweHybrid = function(snow_df){
if (!is.data.frame(snow_df)){ stop("The dataframe given is not a dataframe")}
melt_type = unique(snow_df$melt_types)
melt_type = melt_type[melt_type != "swe" && melt_type != "sweHybrid"]
if (length(melt_type) > 0){
print(snow_df)
stop("Dataframe has unkown melt type when only swe and sweHybrid are allowed")
}
}
swes_melt_out_dates = swes_df %>%
group_by(site_id, melt_types) %>%
mutate(is_melt_out_date = vectorized_is_melt_date_sum(Date, .data, swes_df, all_or_any_string = "all", Snot_melt = 10))
ggplot(data = swes_melt_out_dates) +
geom_line(mapping = aes(x = Date, y = Sum.Melt, color = c(site_id, melt_types)))+
geom_vline(data = swe_melt_out_dates[swe_melt_out_dates$is_melt_out_date, ], aes(xintercept = Date, color = c(site_id, melt_types)), linewidth=.75) +
scale_x_date(date_labels = "%Y-%m-%d")
ggplot(data = swes_melt_out_dates) +
geom_line(mapping = aes(x = Date, y = Sum.Melt, color = melt_types:site_id))+
geom_vline(data = swe_melt_out_dates[swe_melt_out_dates$is_melt_out_date, ], aes(xintercept = Date, color = melt_types:site_id), linewidth=.75) +
scale_x_date(date_labels = "%Y-%m-%d")
ggplot(data = swes_melt_out_dates) +
geom_line(mapping = aes(x = Date, y = Sum.Melt, color = melt_types, linetype = site_id))+
geom_vline(data = swe_melt_out_dates[swe_melt_out_dates$is_melt_out_date, ], aes(xintercept = Date, color = melt_types, linetype = site_id), linewidth=.75) +
scale_x_date(date_labels = "%Y-%m-%d")
# ------------------ Lets find the Melt out date! ------------------------------#
#Default Values.  (WARNING THIS CHANGES ALL DEFAULT VALUES IN THIS FUNCTION)
default_smelt = 0 #The value that Melt must be less than to consider for melt out
default_snot_melt = 10 #The Value that Melt must be greater than to consider not melt
default_prev_days = 15 # The number of days previous to the date that must be
# greater than Snot_Melt
default_all_or_any = "any"  #can also be set to "any"
default_area_value_method = "Sum.Melt"
# This function tests if a specific date matches the "melt_out_date" criteria
# True if Snow Melt at Date is less than Smelt_out threshold AND
#    Snow Melt of previous 50 days > Snot_melt threshold
# Else
#   False
#
#  IMPORTANT:  This function only works for SWE and SWEHybrid.  There would need
#     to be a different function if we were interested in using Melt to determin
#     melt out.  I would argue that using melt does not make sense since melt
#     is still happending nonce melt out occurs.  And that melt out is a
#     somehwat arbitrarie value associated with a pond "opening" and NOT with
#     all snow being gone.
#
#
# Input
# date = A specific Date
# site_melt_data = Df of a SINGLE site melt
#     Each of constants associated with these methods must be thought through
#       carefully to tune our melt date appropriately.
#
# (OPTIONAL)  Below
# master_df = dataframe from wich the .data pronoun can compair to recreate dataframe (see make_dataframe_from_data)
# all_or_any_previous = String either "all" or "any"   Deliniates if all dates within previous days or any dates within previous days must be greater than the Snot_melt value
# area_value_method = String (Sum.Melt, Median.Melt, Mean.Melt, Max.Melt, Min.Melt) The method with wich the areas melt value is averaged/summed etc
# Smelt_out, Snot_Melt, previous_days = Numerical  Descriptions above in default params
#
#
# Return
#   Boolean = TRUE or FALSE if the target date matches the criteria for being a "melt out date"
is_melt_date_sum = function(target_date, site_melt_data, master_df = NULL, all_or_any_string = default_all_or_any, area_value_method = default_area_value_method, Smelt_out = default_smelt, Snot_melt = default_snot_melt, previous_days = default_prev_days){
if (!is.data.frame(site_melt_data)){
if(is.list(site_melt_data)){
site_melt_data = make_dataframe_from_data(site_melt_data, master_df)
}else{
stop("site_melt_data is neither a DF nor a .data type.")
}
}
check_if_not_swe_or_sweHybrid(site_melt_data) #Checks if this is the "melt" meltType
# Gets previous dates etc
temp_previous_days_df = site_melt_data[site_melt_data$Date >= (target_date - previous_days), ]
previous_days_df = temp_previous_days_df[temp_previous_days_df$Date < target_date, ]
if (nrow(previous_days_df) < (previous_days-1)){
warning("For the date below the 'previous days' calculation resulted in fewer than the required number of days and the date was dropped.")
warning(target_date)
warning(nrow(previous_days_df))
print("CHECK THE WARNINGS")
return(FALSE)
}
melt_value = site_melt_data[[area_value_method]][site_melt_data$Date == target_date]
if (melt_value <= Smelt_out && all_or_any(previous_days_df, area_value_method, Snot_melt, all_or_any_string) && nrow(previous_days_df) > 0 ){
print("Came out True")
print(target_date)
return(TRUE)
}else{
return(FALSE)
}
}
#INTERNAL USE ONLY
# Evals the all or any condition and perform evaulation on the df
# input
#   previous_days_df = df of all previous days
#   area_valuy_method = string representing the area_value_method
#   all_or_any_string = string delineating any or all
all_or_any = function(previous_days_df, area_value_method, Snot_melt, all_or_any_string){
if (all_or_any_string == "all"){
return(all(previous_days_df[[area_value_method]] >= Snot_melt))
}else if (all_or_any_string == "any"){
return(any(previous_days_df[[area_value_method]] >= Snot_melt))
}else{
stop("any or all variable is not equalt to 'any' or 'all")
}
}
# This is for PIPE operations!   Custom function designed to work with single
# Variables must be Verctorized to work with pip operan
vectorized_is_melt_date_sum <- Vectorize(is_melt_date_sum, "target_date", "site_melt_data")
#makes a dataframe from the .data pronoun.   This is highly annoying but required
# There is some assumption that R will not jumble the lists when we pull them from
# the .data pronoun.   This assumption has not been completely confirmed and is hard to check
# This is done by creating a small dataframe from the .data function and then merging it
# with the larger dataframe and retaining only those rows that match!   It should end up
# being the same length.  If not then something has gone horribly wrong and will throw
# an error
# Input
#   the.data = Pronoun the .data pronoun.   cannot use .data directly without throwing error
#    master_df = large dataframe give that contains all of the .data
make_dataframe_from_data = function(the.data, master_df){
if (is.null(master_df)){stop("the master DF is null")}
date_list = the.data$Date
site_id_list = the.data$site_id
melt_list = the.data$melt_types
the.data_DF = data.frame(Date = date_list, site_id = site_id_list, melt_types = melt_list)
reduced_df = merge(master_df, the.data_DF, by = c("Date", "site_id", "melt_types"))
if (nrow(reduced_df) != length(date_list)){
stop("Something went wrong recreating the .data dataframe the lengths do not match")
}
return(reduced_df)
}
#  This checks if the user passed a DF that has meltType that is Melt
# Rather has a melt type that is NOT swe or sweHybrid.   These methods only work
# with SWE melt types
check_if_not_swe_or_sweHybrid = function(snow_df){
if (!is.data.frame(snow_df)){ stop("The dataframe given is not a dataframe")}
melt_type = unique(snow_df$melt_types)
melt_type = melt_type[melt_type != "swe" && melt_type != "sweHybrid"]
if (length(melt_type) > 0){
print(snow_df)
stop("Dataframe has unkown melt type when only swe and sweHybrid are allowed")
}
}
swes_melt_out_dates = swes_df %>%
group_by(site_id, melt_types) %>%
mutate(is_melt_out_date = vectorized_is_melt_date_sum(Date, .data, swes_df, all_or_any_string = "all", Snot_melt = 5, previous_days = 5))
ggplot(data = swes_melt_out_dates) +
geom_line(mapping = aes(x = Date, y = Sum.Melt, color = melt_types, linetype = site_id))+
geom_vline(data = swe_melt_out_dates[swe_melt_out_dates$is_melt_out_date, ], aes(xintercept = Date, color = melt_types, linetype = site_id), linewidth=.75) +
scale_x_date(date_labels = "%Y-%m-%d")
melt_only_swes = swes_melt_out_dates[swes_melt_out_dates$is_melt_out_date, ]
View(melt_only_swes)
ggplot(data = melt_only_swes) +
geom_vline(aes(xintercept = Date, color = melt_types, linetype = site_id), linewidth=.75) +
scale_x_date(date_labels = "%Y-%m-%d")
ggplot(data = melt_only_swes) +
geom_vline(aes(xintercept = 5, color = melt_types, linetype = site_id), linewidth=.75) +
scale_x_date(date_labels = "%Y-%m-%d")
ggplot(data = melt_only_swes) +
geom_vline(aes(xintercept = Date, color = melt_types, linetype = site_id), linewidth=.75) +
scale_x_date(date_labels = "%Y-%m-%d")
ggplot(data = melt_only_swes) +
geom_line(mapping = aes(x = Date, y = Sum.Melt, color = melt_types, linetype = site_id))+
scale_x_date(date_labels = "%Y-%m-%d")
ggplot(data = melt_only_swes) +
geom_point(mapping = aes(x = Date, y = Sum.Melt, color = melt_types, linetype = site_id))+
scale_x_date(date_labels = "%Y-%m-%d")
ggplot(data = swes_melt_out_dates) +
geom_line(mapping = aes(x = Date, y = Sum.Melt, color = melt_types, linetype = site_id))+
geom_vline(data = swe_melt_out_dates[swe_melt_out_dates$is_melt_out_date, ], aes(xintercept = Date, color = melt_types, linetype = site_id), linewidth=.75) +
scale_x_date(date_labels = "%Y-%m-%d")
ggplot(data = swes_melt_out_dates) +
geom_line(mapping = aes(x = Date, y = Sum.Melt, color = melt_types, linetype = site_id))+
geom_vline(data = swes_melt_out_dates[swes_melt_out_dates$is_melt_out_date, ], aes(xintercept = Date, color = melt_types, linetype = site_id), linewidth=.75) +
scale_x_date(date_labels = "%Y-%m-%d")
swes_melt_out_dates = swes_df %>%
group_by(site_id, melt_types) %>%
mutate(is_melt_out_date = vectorized_is_melt_date_sum(Date, .data, swes_df, all_or_any_string = "all", Snot_melt = 5, previous_days = 2))
ggplot(data = swes_melt_out_dates) +
geom_line(mapping = aes(x = Date, y = Sum.Melt, color = melt_types, linetype = site_id))+
geom_vline(data = swes_melt_out_dates[swes_melt_out_dates$is_melt_out_date, ], aes(xintercept = Date, color = melt_types, linetype = site_id), linewidth=.75) +
scale_x_date(date_labels = "%Y-%m-%d")
clear
library(RPostgres) # The database driver
library(DBI) # Functions needed to interact with the database
library(rstudioapi) # Package that asked for credentials
library(tcltk)
library(rstudioapi)
library(dplyr)
#------------- Add functions ---------------------------------------------------#
source("f_get_site_melt_info.R")
library(RPostgres) # The database driver
library(DBI) # Functions needed to interact with the database
library(rstudioapi) # Package that asked for credentials
library(tcltk)
library(rstudioapi)
library(dplyr)
#------------- Add functions ---------------------------------------------------#
source("f_get_site_melt_info.R")
# ------------------ Lets find the Melt out date! ------------------------------#
#Default Values.  (WARNING THIS CHANGES ALL DEFAULT VALUES IN THIS FUNCTION)
default_smelt = 5 #The value that Melt must be less than to consider for melt out
default_snot_melt = 10 #The Value that Melt must be greater than to consider not melt
default_prev_days = 15 # The number of days previous to the date that must be
# greater than Snot_Melt
default_all_or_any = "any"  #can also be set to "any"
default_area_value_method = "Sum.Melt"
# This function tests if a specific date matches the "melt_out_date" criteria
# True if Snow Melt at Date is less than Smelt_out threshold AND
#    Snow Melt of previous 50 days > Snot_melt threshold
# Else
#   False
#
#  IMPORTANT:  This function only works for SWE and SWEHybrid.  There would need
#     to be a different function if we were interested in using Melt to determin
#     melt out.  I would argue that using melt does not make sense since melt
#     is still happending nonce melt out occurs.  And that melt out is a
#     somehwat arbitrarie value associated with a pond "opening" and NOT with
#     all snow being gone.
#
#
# Input
# date = A specific Date
# site_melt_data = Df of a SINGLE site melt
#     Each of constants associated with these methods must be thought through
#       carefully to tune our melt date appropriately.
#
# (OPTIONAL)  Below
# master_df = dataframe from wich the .data pronoun can compair to recreate dataframe (see make_dataframe_from_data)
# all_or_any_previous = String either "all" or "any"   Deliniates if all dates within previous days or any dates within previous days must be greater than the Snot_melt value
# area_value_method = String (Sum.Melt, Median.Melt, Mean.Melt, Max.Melt, Min.Melt) The method with wich the areas melt value is averaged/summed etc
# Smelt_out, Snot_Melt, previous_days = Numerical  Descriptions above in default params
#
#
# Return
#   Boolean = TRUE or FALSE if the target date matches the criteria for being a "melt out date"
is_melt_date_sum = function(target_date, site_melt_data, master_df = NULL, all_or_any_string = default_all_or_any, area_value_method = default_area_value_method, Smelt_out = default_smelt, Snot_melt = default_snot_melt, previous_days = default_prev_days){
if (!is.data.frame(site_melt_data)){
if(is.list(site_melt_data)){
site_melt_data = make_dataframe_from_data(site_melt_data, master_df)
}else{
stop("site_melt_data is neither a DF nor a .data type.")
}
}
check_if_not_swe_or_sweHybrid(site_melt_data) #Checks if this is the "melt" meltType
# Gets previous dates etc
temp_previous_days_df = site_melt_data[site_melt_data$Date >= (target_date - previous_days), ]
previous_days_df = temp_previous_days_df[temp_previous_days_df$Date < target_date, ]
if (nrow(previous_days_df) < (previous_days-1)){
warning("For the date below the 'previous days' calculation resulted in fewer than the required number of days and the date was dropped.")
warning(target_date)
warning(nrow(previous_days_df))
print("CHECK THE WARNINGS")
return(FALSE)
}
melt_value = site_melt_data[[area_value_method]][site_melt_data$Date == target_date]
if (melt_value <= Smelt_out && all_or_any(previous_days_df, area_value_method, Snot_melt, all_or_any_string) && nrow(previous_days_df) > 0 ){
print("Came out True")
print(target_date)
return(TRUE)
}else{
return(FALSE)
}
}
#INTERNAL USE ONLY
# Evals the all or any condition and perform evaulation on the df
# input
#   previous_days_df = df of all previous days
#   area_valuy_method = string representing the area_value_method
#   all_or_any_string = string delineating any or all
all_or_any = function(previous_days_df, area_value_method, Snot_melt, all_or_any_string){
if (all_or_any_string == "all"){
return(all(previous_days_df[[area_value_method]] >= Snot_melt))
}else if (all_or_any_string == "any"){
return(any(previous_days_df[[area_value_method]] >= Snot_melt))
}else{
stop("any or all variable is not equalt to 'any' or 'all")
}
}
# This is for PIPE operations!   Custom function designed to work with single
# Variables must be Verctorized to work with pip operan
vectorized_is_melt_date_sum <- Vectorize(is_melt_date_sum, "target_date", "site_melt_data")
#makes a dataframe from the .data pronoun.   This is highly annoying but required
# There is some assumption that R will not jumble the lists when we pull them from
# the .data pronoun.   This assumption has not been completely confirmed and is hard to check
# This is done by creating a small dataframe from the .data function and then merging it
# with the larger dataframe and retaining only those rows that match!   It should end up
# being the same length.  If not then something has gone horribly wrong and will throw
# an error
# Input
#   the.data = Pronoun the .data pronoun.   cannot use .data directly without throwing error
#    master_df = large dataframe give that contains all of the .data
make_dataframe_from_data = function(the.data, master_df){
if (is.null(master_df)){stop("the master DF is null")}
date_list = the.data$Date
site_id_list = the.data$site_id
melt_list = the.data$melt_types
the.data_DF = data.frame(Date = date_list, site_id = site_id_list, melt_types = melt_list)
reduced_df = merge(master_df, the.data_DF, by = c("Date", "site_id", "melt_types"))
if (nrow(reduced_df) != length(date_list)){
stop("Something went wrong recreating the .data dataframe the lengths do not match")
}
return(reduced_df)
}
#  This checks if the user passed a DF that has meltType that is Melt
# Rather has a melt type that is NOT swe or sweHybrid.   These methods only work
# with SWE melt types
check_if_not_swe_or_sweHybrid = function(snow_df){
if (!is.data.frame(snow_df)){ stop("The dataframe given is not a dataframe")}
melt_type = unique(snow_df$melt_types)
melt_type = melt_type[melt_type != "swe" && melt_type != "sweHybrid"]
if (length(melt_type) > 0){
print(snow_df)
stop("Dataframe has unkown melt type when only swe and sweHybrid are allowed")
}
}
library(RPostgres) # The database driver
library(DBI) # Functions needed to interact with the database
library(rstudioapi) # Package that asked for credentials
library(tcltk)
library(rstudioapi)
library(lubridate)
library(dplyr)
library(ggplot2)
#------------- Add functions ---------------------------------------------------#
source("../Pull_Ribbitr_Ponds_Snow_melt/f_connect_to_database.R")
source("f_matlab_to_datetime.R")
# --------------------- Install Required Packages ----------------------------#
if (!require(librarian)){
install.packages("librarian")
library(librarian)
}
# librarian downloads, if not already downloaded, and reads in needed packages
librarian::shelf(tidyverse, DBI, RPostgres, dbplyr, kableExtra, tcltk)
# ------------------------------------------------------------------------------#
#  User Designated variables
debug = FALSE
specific_melt_df_file = FALSE #Can set a specific file if you want.  Otherwise will only get the most recent files
# This file must have been generated by the Parse_SPIReS_MODIS scripts. and be in the right DF format
# Column Names:  (probably... unless something changed)
# ["site_id", Date", "Sum Melt", "Mean Melt", "Median Melt", "Max Melt", "Min Melt", "Standard Deviation Melt", "Variance Melt", "Region_Size_m", "Region_Shape", others?]
#--------------------------- End User Designated variables----------------------#
#--------------------------- Get Secrest and File Paths for logs----------------#
# This may need to be updated for your computer.  But this should find file in the master directory for this git project
#. Make sure to update the UPDATE_local_directories.csv file with the correct directories
csv_with_directory_info = read.csv(paste(getwd(), "/../", "UPDATE_local_directories.csv", sep = ""))
secrets_file = csv_with_directory_info[1,2] # Gets user secrets file path
SPIRES_log_directory = csv_with_directory_info[3,2] #Gets the SPIRES logs directory file path (debug folder should be here too)
#--------------------------- Handles Debug Conditions---------------------------#
if (debug){
snow_log_save_path = paste(SPIRES_log_directory, "/debug", sep = "")
}else{  # If not debug
snow_log_save_path = paste(SPIRES_log_directory, "/logs", sep = "")
}
#--------------------------- Find proper melt_df file path-----------------------#
#Get the most recently created CSV file in the snow_log_save_path directory. (either debug or normal)
# Defaults to user specified melt directory (if applicable)
if (specific_melt_df_file == FALSE){ # The user did NOT specify a specific file path
files <- list.files(snow_log_save_path, full.names = TRUE)
# Filter only CSV files
csv_files <- files[grep("\\.csv$", files)]
# Get file info
file_info <- file.info(csv_files)
# Find the most recently created file
snow_df_filepath <- csv_files[which.max(file_info$ctime)]
}else{ #User specified a specific file path
snow_df_filepath = specific_melt_file #set to user file.
}
# Read the CSV file
snow_df <- read.csv(snow_df_filepath)
# ------------------- Drop nans ------------------------------------------------#
# Realistically there shouldnt be any nans... But it appears there are.  This
# Is probably because the snow melt data is not calculated everywhere perfectly
# but I am unsure.   This doesn't affect this protocol that much but it may
# change the parse_SPIRES_Modis values...  To be thought through carefully
before = nrow(snow_df)
snow_df = na.omit(snow_df)
after = nrow(snow_df)
diff = before - after
if (diff > 0){
print("There were NAN rows omitted")
print(diff)
}
# ------------------ Convert all matlab dats to R dates ------------------------#
# We now have all our melt data.  And we want to figure out "melt out" date for each pond and each year.
#  Lets define "melt out" as the date where AFTER BEING HIGH SNOW for some amount of time the SWE or SWE Hybrid decreases below some threshold.
snow_df = snow_df %>%
mutate(Date = matlab2date(Date))
#------------------ Now lest sort by melt_types ------------- ------------------#
melt_df = snow_df[snow_df$melt_types == "melt", ]
swes_df = snow_df[snow_df$melt_types != "melt", ] # A dataframe with only the swe and SweHybrid measurements
#---------- Now lets get a DF of all the Melt out Dates ------------------------#
# Problematically the pipe format isn't quite working with my functions.  I think
# This is because it is passing the Date as a list istead of an individual Date objectf
# sweHybrid_df = snow_df[snow_df$melt_types == "sweHybrid", ]
#sweHybrid_melt_out_dates = sweHybrid_df %>%
#  group_by(site_id) %>%
#  mutate(is_melt_out_date = vectorized_is_melt_date_sum(Date, .data, sweHybrid_df, all_or_any_string = "all", Snot_melt = 10))
# swe_df = snow_df[snow_df$melt_types == "swe", ]
#swe_melt_out_dates = swe_df %>%
#  group_by(site_id) %>%
#  mutate(is_melt_out_date = vectorized_is_melt_date_sum(Date, .data, swe_df, all_or_any_string = "all", Snot_melt = 10))
# This finds the melt dates based on SWE and SWEHybrid values all at once
# May want to break this apart so SWE and SWEHybrid can have different params
swes_melt_out_dates = swes_df %>%
group_by(site_id, melt_types) %>%
mutate(is_melt_out_date = vectorized_is_melt_date_sum(Date, .data, swes_df, all_or_any_string = "all", Snot_melt = 5, previous_days = 5))
